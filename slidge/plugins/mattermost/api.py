import asyncio
import io
import json
import logging
from typing import Optional

import aiohttp
import emoji as emoji_lib
from mattermost_api_reference_client.api.channels import (
    create_direct_channel,
    get_channel_members,
    get_channels_for_team_for_user,
    get_channels_for_user,
    view_channel,
)
from mattermost_api_reference_client.api.files import get_file, upload_file
from mattermost_api_reference_client.api.posts import (
    create_post,
    delete_post,
    get_posts_for_channel,
    update_post,
)
from mattermost_api_reference_client.api.reactions import (
    delete_reaction,
    get_reactions,
    save_reaction,
)
from mattermost_api_reference_client.api.status import (
    get_user_status,
    get_users_statuses_by_ids,
)
from mattermost_api_reference_client.api.teams import get_teams_for_user
from mattermost_api_reference_client.api.users import (
    get_known_users,
    get_profile_image,
    get_user,
    get_user_by_username,
    get_users_by_ids,
)
from mattermost_api_reference_client.client import AuthenticatedClient
from mattermost_api_reference_client.models import (
    Channel,
    Reaction,
    Status,
    Team,
    User,
    ViewChannelJsonBody,
)
from mattermost_api_reference_client.models.create_post_json_body import (
    CreatePostJsonBody,
)
from mattermost_api_reference_client.models.update_post_json_body import (
    UpdatePostJsonBody,
)
from mattermost_api_reference_client.models.upload_file_multipart_data import (
    UploadFileMultipartData,
)
from mattermost_api_reference_client.types import UNSET, File, Unset


class MattermostException(Exception):
    pass


class ContactNotFound(MattermostException):
    pass


class MattermostClient:
    # TODO: this should be autogenerated using a template in mattermost_api_reference_client

    def __init__(self, *args, **kwargs):
        self.http = AuthenticatedClient(*args, **kwargs)
        self.mm_id: asyncio.Future[str] = asyncio.get_running_loop().create_future()
        self.me: asyncio.Future[User] = asyncio.get_running_loop().create_future()

    async def login(self):
        log.debug("Login")
        me = await get_user.asyncio("me", client=self.http)
        if me is None:
            raise RuntimeError("Could not login")
        self.me.set_result(me)
        my_id = me.id
        if isinstance(my_id, Unset):
            raise RuntimeError("Could not login")
        self.mm_id.set_result(my_id)
        log.debug("Me: %s", me)

    async def get_known_users(self) -> list[str]:
        r = await get_known_users.asyncio_detailed(client=self.http)
        return json.loads(r.content)

    async def get_teams(self) -> list[Team]:
        return await get_teams_for_user.asyncio("me", client=self.http) or []

    async def get_channels(self) -> list[Channel]:
        mm = self.http
        channels = await get_channels_for_user.asyncio("me", client=mm)
        log.debug("Channels: %s", channels)

        if not channels:
            # happens on INRIA's matternost, maybe disabled by admin instance?
            channels = []
            for team in await self.get_teams():
                if isinstance(team.id, Unset):
                    log.warning("Team without ID")
                    continue

                team_channels = await get_channels_for_team_for_user.asyncio(
                    "me", team.id, client=mm
                )

                if not team_channels:
                    log.warning("Team without channels")
                    continue

                for channel in team_channels:
                    channels.append(channel)
        return channels

    async def get_contacts(self):
        me = await self.mm_id
        user_ids = []
        for c in await self.get_channels():
            if c.type != "D":
                continue
            assert isinstance(c.name, str)
            for user_id in c.name.split("__"):
                if user_id != me:
                    user_ids.append(user_id)
        return user_ids

    async def get_channel_members(
        self, channel_id: str, *, page: int = 0, per_page: int = 10
    ):
        members = await get_channel_members.asyncio(
            channel_id, client=self.http, per_page=per_page, page=page
        )
        if members is None:
            raise RuntimeError
        return members

    async def get_users_by_ids(self, user_ids: list[str]) -> list[User]:
        r = await get_users_by_ids.asyncio(json_body=user_ids, client=self.http)
        if r is None:
            raise RuntimeError
        return r

    async def get_user(self, user_id: str):
        r = await get_user.asyncio(user_id, client=self.http)
        if r is None:
            raise RuntimeError
        if isinstance(r.username, Unset):
            raise RuntimeError
        return r

    async def get_users_statuses_by_ids(self, user_ids: list[str]) -> list[Status]:
        r = await get_users_statuses_by_ids.asyncio(
            json_body=user_ids, client=self.http
        )
        if r is None:
            raise RuntimeError
        return r

    async def send_message_to_user(
        self, user_id: str, text: str, thread: Optional[str] = None
    ) -> str:
        await self.mm_id
        mm = self.http

        other = await self.get_user_by_username(user_id)

        direct_channel = await self.get_direct_channel(other.id)

        msg = await create_post.asyncio(
            json_body=CreatePostJsonBody(
                channel_id=direct_channel.id, message=text, root_id=thread or UNSET
            ),
            client=mm,
        )

        if msg is None:
            log.debug("Looks like it's a new thread")
            msg = await create_post.asyncio(
                json_body=CreatePostJsonBody(
                    channel_id=direct_channel.id, message=text
                ),
                client=mm,
            )

        if msg is None:
            raise RuntimeError

        if isinstance(msg.id, Unset):
            raise RuntimeError

        return msg.id

    async def send_message_with_file(self, channel_id: str, file_id: str, thread=None):
        r = await create_post.asyncio(
            json_body=CreatePostJsonBody(
                channel_id=channel_id,
                file_ids=[file_id],
                message="",
                root_id=thread or UNSET,
            ),
            client=self.http,
        )

        if r is None:
            log.debug("Looks like it's a new thread")
            r = await create_post.asyncio(
                json_body=CreatePostJsonBody(
                    channel_id=channel_id, file_ids=[file_id], message=""
                ),
                client=self.http,
            )

        if r is None or isinstance(r.id, Unset):
            raise RuntimeError(r)
        return r.id

    async def get_user_by_username(self, username: str) -> User:
        user = await get_user_by_username.asyncio(username, client=self.http)
        if user is None or isinstance(user.id, Unset):
            raise ContactNotFound("Contact not found")
        return user

    async def get_direct_channel(self, user_id):
        direct_channel = await create_direct_channel.asyncio(
            json_body=[await self.mm_id, user_id], client=self.http
        )
        if direct_channel is None or isinstance(direct_channel.id, Unset):
            raise RuntimeError("Could not create direct channel")
        return direct_channel

    async def get_profile_image(self, user_id: str) -> bytes:
        resp = await get_profile_image.asyncio_detailed(user_id, client=self.http)
        return resp.content

    async def get_file(self, file_id: str):
        resp = await get_file.asyncio_detailed(file_id, client=self.http)
        return resp.content

    async def delete_post(self, post_id: str):
        r = await delete_post.asyncio(post_id, client=self.http)
        if r is not None and not isinstance(r, Unset) and r.status != "ok":
            raise RuntimeError("Could not delete post %s", post_id)

    async def update_post(self, post_id: str, body: str):
        r = await update_post.asyncio(
            post_id,
            client=self.http,
            json_body=UpdatePostJsonBody(id=post_id, message=body),
        )
        if r is None or isinstance(r, Unset):
            raise RuntimeError(r)
        return r.id

    async def get_posts_for_channel(self, channel_id: str):
        r = await get_posts_for_channel.asyncio(
            channel_id, client=self.http, per_page=2
        )
        if r is None or isinstance(r, Unset):
            raise RuntimeError(r)
        return r

    async def upload_file(
        self, channel_id: str, url: str, http_response: aiohttp.ClientResponse
    ):
        data = await http_response.read()
        req = UploadFileMultipartData(
            files=File(file_name=url.split("/")[-1], payload=io.BytesIO(data)),
            channel_id=channel_id,
        )
        r = await upload_file.asyncio(client=self.http, multipart_data=req)
        if (
            r is None
            or isinstance(r, Unset)
            or r.file_infos is None
            or isinstance(r.file_infos, Unset)
            or len(r.file_infos) != 1
        ):
            raise RuntimeError(r)
        return r.file_infos[0].id

    async def react(self, post_id: str, emoji: str):
        return await save_reaction.asyncio(
            client=self.http,
            json_body=Reaction(
                user_id=await self.mm_id,
                post_id=post_id,
                emoji_name=demojize(emoji),
            ),
        )

    async def get_reactions(self, post_id: str) -> set[tuple[str, str]]:
        try:
            r = await get_reactions.asyncio(post_id, client=self.http)
        except TypeError:
            return set()
        if not r:
            return set()
        return {(x.user_id, emojize(x.emoji_name)) for x in r}  # type:ignore

    async def delete_reaction(self, post_id: str, emoji: str):
        emoji_name = demojize(emoji)
        await delete_reaction.asyncio(
            await self.mm_id, post_id, emoji_name=emoji_name, client=self.http
        )

    async def view_channel(self, channel_id: str):
        await view_channel.asyncio(
            await self.mm_id,
            client=self.http,
            json_body=ViewChannelJsonBody(channel_id=channel_id),
        )

    async def get_user_status(self, user_id: str):
        return await get_user_status.asyncio(user_id, client=self.http)


def emoji_name_conversion(x: str):
    return x.replace("_3_", "_three_").replace("thumbsup", "+1")


def emojize(x: str):
    return emoji_lib.emojize(f":{emoji_name_conversion(x)}:", language="alias")


def demojize(emoji_char: str):
    return emoji_name_conversion(
        emoji_lib.demojize(emoji_char, delimiters=("", ""), language="alias")
    )


log = logging.getLogger(__name__)
